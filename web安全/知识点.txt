一、sql注入。
概念：所谓SQL注入，就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。

危害：

1. 查询数据库中敏感信息。

2. 绕过认证。

3. 添加、删除、修改服务器数据。

4. 拒绝服务。?id=(BENCHMARK(100000000, MD5(RAND()));

防御:
addslashes() 函数返回在预定义字符之前添加反斜杠的字符串。
mysql_escape_string() 转义特殊字符

对sql进行预处理占位符:
    $sql = "select * from the_table where id = ? and uid = ?";
    $st = $pdo->prepare($sql);

自定义函数过滤
根据参数做严格验证



二、XSS跨站脚本
概念：恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意用户的特殊目的。

危害：
盗取用户COOKIE信息。
跳转到钓鱼网站。
操作受害者的浏览器，查看受害者网页浏览信息等。
蠕虫攻击。

解决方法:
htmlspecialchars
输出过滤，PHP端输出到view的模板页面上的数据都需要经过过滤：
web端：innerHtml 赋值

三、CSRF跨站攻击
攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，
比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。



CSRF攻击原理
要完成一次CSRF攻击，受害者必须依次完成两个步骤：
1.登录受信任网站A，并在本地生成Cookie。
2.在不登出A的情况下，访问危险网站B。
1.你不能保证你登录了一个网站后，不再打开一个新页面并访问另外的网站。
2.你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。

防范：
在请求地址中添加 token 并验证

在 HTTP 头中自定义属性并验证

验证 HTTP Referer 字段

验证码
每次用户提交都需要用户在表单中填写一个随机字符串，这个方案可以完全解决CSRF，但在易用性不好􏰻
生成验证token
生产页面的时候在服务端生产token，传到页面，页面提交的时候将token 传到服务端验证

不同的表单包含一个不同的伪随机值
在实现时需要注意一点:“并行会话的兼容”。
如果用户在一个站点上同一页面同时打开了两个不同的表单，CSRF保护措施不应该影响到他对任何表单的提交,不能提交一个表单后,另一个表单的验证失败了.



