事务隔离级别：
脏读、 幻读、 不可重复读


1、脏读（Read Uncommitted）
通俗的讲，一个事务在处理过程中读取了另外一个事务未提交的数据。
你都还没提交，我就读到了你刚操作的数据，万一你回滚了怎么办，你说这脏不脏。

例子：
假设打赏的逻辑是：① 我的账户+1元；② 你的账户-1元。
当你执行到第一个步骤，我去查询我的账户已经是2元了，很开心！！！宣布请大家去撸串！！！
但是最后扣款的时候发现你余额不足了，回滚了，我的1元没了，就很难受！！


2、不可重复读（Non-repeatable Read）
通俗的讲，一个事务范围内，多次查询某个数据，却得到不同的结果。
与脏读的区别：脏读是读到未提交的数据，而不可重复读读到的却是已经提交的数据，但实际上是违反了事务的一致性原则。

例子：
假设我查了下账户余额，看到你们给小编打赏了1块钱，很开心！！！宣布请大家去撸串！！！
在付款之前，钱被另外一个人取走，又查询到没钱了，被留下来洗碗了！！！
因为我查询完后，这条数据没锁住，又被别的事务更新了，导致当前事务每次都是读到最新的数据。



3、幻读
在Repeatable Read隔离级别下，一个事务可能会遇到幻读（Phantom Read）的问题。
事务A读取与搜索条件相匹配的若干行。事务B以插入或删除行等方式来修改事务A的结果集，然后再提交。
举例：
在一个事务A中，第一次查询某条记录，是没有的，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。
实际上，在InnoDB引擎中，对于索引的扫描，不仅锁住扫描到的索引，而且还锁住这些索引覆盖的范围（gap），因此这个范围是内插入数据是不允许的。





