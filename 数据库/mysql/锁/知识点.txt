一、悲观锁
先获取锁在操作逻辑业务最后释放锁。
所以要先获取锁成功了才能继续后续业务操作。
任何时刻只要一个请求持有锁，其他的请求只能等待锁释放，持有锁的请求处理完逻辑释放锁。

实现：(属于行锁)
select * from tbl_user where id=1 for update;(属于排他锁(写锁))
数据库的引擎为 innoDB
操作位于事务块中（BEGIN/COMMIT）
关闭mysql数据库的自动提交属性
set autocommit=0;




二、乐观锁：
乐观锁认为一般情况下数据不会造成冲突，所以在数据进行提交更新时才会对数据的冲突与否进行检测。如果没有冲突那就OK；如果出现冲突了，
则返回错误信息并让用户决定如何去做。

1、通过添加版本号的字段实现 version

操作前先查询数据获取版本号字段
操作时根据获取的版本号和当前版本号对比
相等则更新且版本号加1，不相等执行错误。


悲观锁 和 乐观锁的区别：

两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，
这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，
这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。


行锁 和 表锁
1.主要是针对锁粒度划分的，一般分为：行锁、表锁
（1）行锁：访问数据库的时候，锁定整个行数据，防止并发错误。

（2）表锁：访问数据库的时候，锁定整个表数据，防止并发错误。

2.行锁 和 表锁 的区别：

表锁： 开销小，加锁快，不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低

行锁： 开销大，加锁慢，会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高


表锁和行锁应用场景：

表级锁使用与并发性不高，以查询为主，少量更新的应用，比如小型的web应用；

而行级锁适用于高并发环境下，对事务完整性要求较高的系统，如在线事务处理系统。


共享锁又称读锁 read lock
排他锁 exclusive lock（也叫writer lock）又称写锁。

行锁又分共享锁和排他锁
共享锁：共享锁又叫做读锁，所有的事务只能对其进行读操作不能写操作，加上共享锁后在事务结束之前其他事务只能再加共享锁，
        除此之外其他任何类型的锁都不能再加了。

排他锁：若某个事物对某一行加上了排他锁，只能这个事务对其进行读写，在此事务结束之前，其他事务不能对其进行加任何锁，
       其他进程可以读取,不能进行写操作，需等待其释放。

Innodb中的行锁与表锁
只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！
行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。
行级锁的缺点是：由于需要请求大量的锁资源，所以速度慢，内存消耗大。







