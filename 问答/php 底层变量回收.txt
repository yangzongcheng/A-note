我们直接 unset() 掉一个没有被其他变量引用的变量时，就会让这个变量的引用计数变为0。
这时，PHP 默认的垃圾回收机制就会直接清除掉这个变量

php5和php7的垃圾回收机制都是利用引用计数


php5和php7不同点

1、PHP5标量数据类型会计数，PHP7标量数据类型不再计数，不需要单独分配内存
2、PHP7的zval 需要的内存不再是单独从堆上分配，不再自己存储引用计数。
3、PHP7的复杂数据类型（比如数组和对象）的引用计数由其自身来存储。


垃圾回收算法

复制代码
1、对每个根缓冲区中的根zval按照深度优先遍历算法遍历所有能遍历到的zval，并将每个zval的refcount减1，
    同时为了避免对同一zval多次减1(因为可能不同的根能遍历到同一个zval)，
　　每次对某个zval减1后就对其标记为“已减”。

2、再次对每个缓冲区中的根zval深度优先遍历，如果某个zval的refcount不为0，则对其加1，否则保持其为0。

3、清空根缓冲区中的所有根(注意是把这些zval从缓冲区中清除而不是销毁它们)，然后销毁所有refcount为0的zval，并收回其内存。
如果不能完全理解也没有关系，只需记住PHP5.3的垃圾回收算法有以下几点特性：

1、并不是每次refcount减少时都进入回收周期，只有根缓冲区满额后在开始垃圾回收。

2、可以解决循环引用问题。

3、可以总将内存泄露保持在一个阈值以下。