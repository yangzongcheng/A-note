我们直接 unset() 掉一个没有被其他变量引用的变量时，就会让这个变量的引用计数变为0。
这时，PHP 默认的垃圾回收机制就会直接清除掉这个变量

php5和php7的垃圾回收机制都是利用引用计数


php5和php7不同点

1、PHP5标量数据类型会计数，PHP7标量数据类型不再计数，不需要单独分配内存
2、PHP7的zval 需要的内存不再是单独从堆上分配，不再自己存储引用计数。
3、PHP7的复杂数据类型（比如数组和对象）的引用计数由其自身来存储。

zval的结构体：
struct _zval_struct {
    union {
        long lval;
        double dval;
        struct {
            char *val;
            int len;
        } str;
        HashTable *ht;
        zend_object_value obj;
    } value;                    //变量value值
    zend_uint refcount__gc;   //引用计数内存中使用次数，为0删除该变量
    zend_uchar type;           //变量类型
    zend_uchar is_ref__gc;    //区分是否是引用变量
};
每一个php变量都会由变量类型、value值、引用计数次数和是否是引用变量四部分组成

引用计数清0
当变量容器的ref_count计数清0时，表示该变量容器就会被销毁，实现了内存回收，这也是php5.3版本之前的垃圾回收机制

循环引用引发的内存泄露问题
但是php5.3版本之前的垃圾回收机制存在一个漏洞，即当数组或对象内部子元素引用其父元素，而此时如果发生了删除其父元素的情况，
此变量容器并不会被删除，因为其子元素还在指向该变量容器，但是由于所有作用域内都没有指向该变量容器的符号，所以无法被清除，
因此会发生内存泄漏，直到该脚本执行结束

新的垃圾回收机制
php5.3版本之后引入根缓冲机制，即php启动时默认设置指定zval数量的根缓冲区（默认是10000），当php发现有存在循环引用的zval时，
就会把其投入到根缓冲区，当根缓冲区达到配置文件中的指定数量（默认是10000）后，就会进行垃圾回收，
以此解决循环引用导致的内存泄漏问题

确认为垃圾的准则
1、如果引用计数减少到0，所在变量容器将被清除(free)，不属于垃圾
2、如果一个zval 的引用计数减少后还大于0，那么它会进入垃圾周期。其次，在一个垃圾周期中，通过检查引用计数是否减1，
并且检查哪些变量容器的引用次数是零，来发现哪部分是垃圾。


垃圾回收算法
复制代码
1、对每个根缓冲区中的根zval按照深度优先遍历算法遍历所有能遍历到的zval，并将每个zval的refcount减1，
    同时为了避免对同一zval多次减1(因为可能不同的根能遍历到同一个zval)，
　　每次对某个zval减1后就对其标记为“已减”。

2、再次对每个缓冲区中的根zval深度优先遍历，如果某个zval的refcount不为0，则对其加1，否则保持其为0。

3、清空根缓冲区中的所有根(注意是把这些zval从缓冲区中清除而不是销毁它们)，然后销毁所有refcount为0的zval，并收回其内存。
如果不能完全理解也没有关系，只需记住PHP5.3的垃圾回收算法有以下几点特性：

1、并不是每次refcount减少时都进入回收周期，只有根缓冲区满额后在开始垃圾回收。

2、可以解决循环引用问题。

3、可以总将内存泄露保持在一个阈值以下。


详情参考：https://segmentfault.com/a/1190000018369789