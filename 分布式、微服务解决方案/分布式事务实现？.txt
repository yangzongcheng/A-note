数据库事务拥有四个特性，原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）：

什么事分布式事务：
多个服务同时修改记录时，保证数据的一致性.

redis分布式思路:setnx
通过在redis设置一个唯一锁，如果存在key，则认为有其他客户端在使用，等待锁释放。
如果不存在key，说明没有客户端使用，可以执行任务，执行完毕，解锁，删除key.

死锁问题：设置key 超时时间


锁实现的注意点

互斥: 任意时刻, 只能有一个客户端获得锁
不会死锁: 客户端持有锁期间崩溃, 没有主动解除锁, 能保证后续的其他客户端获得锁
锁归属标识: 加锁和解锁的必须是同一个客户端, 客户端不能解掉非自己持有的锁(锁应具备标识)
如果是Redis集群, 还得考虑具有容错性: 只要大部分Redis节点正常运行, 客户端就可以加锁和解锁.







业务场景

分布式项目部署的环境下，使用分布式锁来保证缓存的单线程写，这样可以避免同一时间大量缓存失效导致请求全部落在DB上。
多客户端同时并发写一个key，可能本来应该先到的数据后到了，导致数据版本错了。或者是多客户端同时获取一个key，修改值之后再写回去，只要顺序错了，数据就错了。
订单防超卖。
总之，数据是需要保证唯一性，就需要分布式锁。
分布式锁常用实现方案

分布式锁通常是借助于一个第三方组件并利用它自身的排他性来达到多进程的互斥。如下：
1. 基于数据库实现分布式锁
2. 基于缓存，实现分布式锁，如redis
3. 基于Zookeeper实现分布式锁
基于数据库：锁实现也有两种方式，一是基于数据库表(创建一张锁表)，另一种是基于数据库排他锁。
基于zookeeper：锁的实现是依靠临时有序节点，每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。
基于缓存：下面我们要重点讲的就是redis。基于 Redis 的 NX EX 参数。
基于redis的分布式锁实现

